//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = false;
}

// -----------------------------------------------------------------------------


PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.attributes.*;
import java.util.ArrayList;

//...

public class alike {
   //...

   static SymbolTable st;

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"boolean","char","character", "integer", "null", "array", 
			"mod", "not", "and", "or",
			"if", "elsif", "else", "then", "while", "loop", "true", "false",
			"procedure", "function", "is", "ref", "of", "begin", "end", "return",
			"skip_line", "put", "put_line", "get", "char2int", "int2char"
		};

		//st.insertReservedWords(palsRes);
	}

	private static void iterarYanadirEnTablaDeSimbolos(ArrayList<Token> ids, Attributes at){
		Symbol s = null;
		for (Token t : ids) {
			if (at.isArray) {
				s = new SymbolArray(t.image, at.intList.get(0), at.intList.get(1), at.type);
				at.parList.add(s);
			}
			else {
				if (at.type == Symbol.Types.BOOL) {
					s = new SymbolBool(t.image);
					at.parList.add(s);
				}
				else if (at.type == Symbol.Types.INT) {
					s = new SymbolInt(t.image);
					at.parList.add(s);
				}
				else if (at.type == Symbol.Types.CHAR) {
					s = new SymbolChar(t.image);
					at.parList.add(s);
				}
			}
			try {
				st.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e) {
				System.err.println("Already Defined: " + e.getMessage());
			}
		}
	}
   
   public static void main(String[] args) {
	   alike parser = null;
	   
		st = new SymbolTable();
    	initSymbolTable();

	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());

	   }
	   catch (ParseException e) {
			System.err.println("Parse_exception: " + e.getMessage());
	   }
	   //...
   }
}
PARSER_END(alike)

// ----------------------------------------------------------------------------

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #UNDERSCORE: "_" >
}

SKIP : { 
	< tSPACE: " " >
| 	< tNL: "\n" >
|	< tTAB: "\t" >
|	< tENTER: "\r" >
| 	< tCOMENTARIO: "--"(~["\n"])* >
}

TOKEN : { // Tipos
	< tBOOL: "boolean" >
|	< tCHAR: "char" >
|	< tCHARACTER: "character" >
|   < tINTEGER: "integer" >
|	< tSTRING: "string" >
|	< tNULL: "null" >
|	< tARRAY: "array" >
|	< tCONST_INT: (["0"-"9"])+ >
|	< tCONST_CHAR: "\'"(~["\n","\t","\r","\f","\b","\'","\""] | ("\"\"") | ("\'\'"))"\'" >
| 	< tCONST_STRING: "\""(~["\n","\t","\r","\f","\b","\'","\""] | ("\"\"") | ("\'\'"))*"\"" >
}

TOKEN : { // Operadores
	< tASIGN: ":=" >
|	< tSUM: "+" >
|   < tRES: "-" >
|	< tEQU: "=" >
|	< tGT: ">" >
|	< tLT: "<" >
|	< tGE: ">=" >
|	< tLE: "<=" >
|	< tDIF: "/=" >
|	< tMUL: "*" >
|	< tMOD: "mod" >
|	< tDIV: "/" >
|	< tNOT: "not" >
|	< tAND: "and" >
|	< tOR: "or" >
}

TOKEN : { // Sintaxis reservada estructuras simples
	< tIF: "if" >
|	< tELIF: "elsif" >
|	< tELSE: "else" >
|	< tTHEN: "then" >
|	< tWHILE: "while" >
|	< tLOOP: "loop" >
|	< tTRUE: "true" >
|	< tFALSE: "false" >
}

TOKEN : { // Sintaxis reservada funciones
	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tREF: "ref" >
|	< tOF: "of" >
|	< tBEGIN: "begin" >
|	< tEND: "end" >
|	< tRETURN: "return" >
}

TOKEN : { // Instrucciones E/S
	< tSKIP_LN: "skip_line" >
|	< tPUT: "put" >
|	< tPUT_LN: "put_line" >
|	< tGET: "get" >
|	< tCHAR2INT: "char2int" >
|	< tINT2CHAR: "int2char" >
}

TOKEN : { // Separadores
	< tPUNTO: "." >
|	< tCOMA:	"," >
|	< tDOSPUNTOS: ".." >
|	< tDOBLEPUNTO: ":" >
|	< tPUNTOCOMA: ";" >
|	< tCORCHETES_OPEN: "[" >
|	< tCORCHETES_CLOSE: "]" >
|	< tPARENTESIS_OPEN: "(" >
|	< tPARENTESIS_CLOSE: ")" >
|	< tID: ["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","0"-"9","_"])* >
}

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token t) {

		 String[] nombresTokens = {
			"letra", "digito", "barra baja", "espacio", "fin de linea", "tabulador", "retorno", "comentario",
			"boolean", "char", "character", "integer", "null", "array", "const integer", "const char", "const string",
			"asignacion", "suma", "resta", "comparacion igualdad", "comparacion mayor estricto", "comparacion menor estricto", 
			"comparacion mayor o igual", "comparacion menor o igual", "comparacion diferencia", "multiplicacion", "modulo", "division", "negacion logica", 
			"operador logico", "operador logico", "token", "token", "token", "token", "token", "token", "constante aritmetica", "constante aritmetica", 
			"token", "token", "token", "token", "token", "token", "token", "token", "funcion reservada", "funcion reservada", "funcion reservada", 
			"funcion reservada", "funcion reservada", "funcion reservada", "token separador", "token separador", "token separador", "token separador",
			"token separador", "token separador", "token separador", "token separador", "token separador", "identificador"
		};

		int linea = t.beginLine;
		int columna = t.beginColumn;
		String image = t.image;
		if (t.kind != 0){ // Si es distinto de fin de linea
			System.out.println("(" + linea + "," + columna + "): " + nombresTokens[t.kind-1] + " \"" + image + "\"");
		}
	}
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
/*void Programa() : 
{
	//Token t;
}
{
   ( 
	   < tBEGIN >
	   | 
	   < tBOOL > | < tCHAR > | < tCHARACTER > | < tINTEGER > | < tNULL > | < tARRAY > | < tCONST_INT > | < tCONST_CHAR > | < tCONST_STRING > 
	   |
	   < tASIGN > | < tSUM > | < tRES > | < tEQU > | < tGT > | < tLT > | < tGE > | < tLE > | < tMUL > | < tMOD > | < tDIV > | < tNOT > | < tDIF > | < tAND > | < tOR >
	   |
	   < tIF > | < tELIF > |	< tTHEN > |	< tWHILE > | < tLOOP > | < tTRUE > | < tFALSE > | <tELSE>
	   |
	   < tPROCEDURE > | < tIS > | < tREF > | < tEND > | < tRETURN > | < tOF > | <tFUNCTION>
	   |
	   < tSKIP_LN > | < tPUT > | < tPUT_LN > | < tGET > | <tCHAR2INT> | <tINT2CHAR> 
	   |
	   < tPUNTO > |	< tCOMA > |	< tDOSPUNTOS > | < tDOBLEPUNTO > | < tPUNTOCOMA > |	< tCORCHETES_OPEN > | < tCORCHETES_CLOSE > | < tPARENTESIS_OPEN > |	< tPARENTESIS_CLOSE > | < tID >
   )+
   < EOF >
}*/

 
void Programa() : 
{
	Token t;
	Attributes at = new Attributes();
	
}
{
	<tPROCEDURE>
	t = <tID> {
		Symbol s;
		at.parList = new ArrayList<Symbol>();
		s = new SymbolProcedure(t.image,at.parList);
		try {
			st.insertSymbol(s);	
		}
		catch (AlreadyDefinedSymbolException e) {
			//error
		}
	}
	<tIS>
	( declaracion_variables() )?
	( declaracion_procs_funcs() )?
	<tBEGIN>
	instrucciones()
	<tEND>
	<tPUNTOCOMA>
	<EOF>
}
	
void declaracion_procs_funcs() :
{

}
{
	( declaracion_proc_func() )+
}

void declaracion_proc_func() :
{

}
{
	( declaracion_proc() | declaracion_func() )
}

void declaracion_func():
{
	Attributes at = new Attributes();
}
{
	cabecera_funcion(at)
	( declaracion_variables() )?
	<tBEGIN>
	instrucciones() 
	<tEND>
	<tPUNTOCOMA>
	{
		System.err.println(st.toString());
		st.removeBlock();
	}
}

void declaracion_proc():
{
	Attributes at = new Attributes();
}
{
	cabecera_procedimiento(at)
	( declaracion_variables() )?
	<tBEGIN>
	instrucciones() 
	<tEND>
	<tPUNTOCOMA>
	{
		System.err.println(st.toString());
		st.removeBlock();
	}
}

ArrayList<Token> lista_ids():
{
	ArrayList<Token> ids = new ArrayList<Token>();
	Token t;
}
{

	t = <tID> {ids.add(t);} (<tCOMA> t = <tID> {ids.add(t);})*  //Aceptamos que una lista de ids pueda estar formada por un solo id
	{return ids;}
}

void declaracion_variables() :
{

}
{
	( declaracion_var() )+
}

void declaracion_variables_puntocoma() :
{
	Attributes at = new Attributes();
}
{
	( declaracion_var_puntocoma(at) )+
}
		
void tipo_variable(Attributes at) :
{

}
{
	<tBOOL> { at.type = Symbol.Types.BOOL; }
| 	<tCHAR> { at.type = Symbol.Types.CHAR; }
| 	<tCHARACTER> { at.type = Symbol.Types.CHAR; }
| 	<tINTEGER> { at.type = Symbol.Types.INT; }
	
}

void rango(Attributes at) :
{
	Token t1, t2;
}
{
	t1 = <tCONST_INT> <tDOSPUNTOS> t2 = <tCONST_INT> 
	{
		Integer inicio,fin;
		inicio = Integer.valueOf(t1.image);
		fin = Integer.valueOf(t2.image);
		if(inicio > fin) {
			//error
		}
		else {
			at.intList.add(inicio);
			at.intList.add(fin);
		}
	}
}

void estructura_array(Attributes at):
{
}
{
	<tARRAY> <tPARENTESIS_OPEN> rango(at) <tPARENTESIS_CLOSE> <tOF> tipo_variable(at)
	{
		at.isArray = true;
	}
}

void declaracion_var_puntocoma(Attributes at):
{
	ArrayList<Token> ids;
	Attributes at1 = new Attributes(), at2 = new Attributes();
	Symbol s;
}
{
	ids = lista_ids() 
	<tDOBLEPUNTO>
	(<tREF>)?
	( tipo_variable(at1) 
	{ 
		iterarYanadirEnTablaDeSimbolos(ids,at1);
		at.parList = at2.parList;
	} 
| 	
  	estructura_array(at2) 
	{ 
		iterarYanadirEnTablaDeSimbolos(ids,at2); 
		at.parList = at2.parList;
	}
	)
}

void declaracion_var():
{
	ArrayList<Token> ids;
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	ids = lista_ids() 
	<tDOBLEPUNTO>
	( tipo_variable(at1) { iterarYanadirEnTablaDeSimbolos(ids,at1);	} | 	
	  estructura_array(at2) { iterarYanadirEnTablaDeSimbolos(ids,at2); })
	<tPUNTOCOMA>
}

void lista_parametros_funcion_o_proc(Attributes at):
{

}
{
	declaracion_var_puntocoma(at) (<tPUNTOCOMA> declaracion_var_puntocoma(at))*	
}

void cabecera_procedimiento(Attributes at) :
{
	Token t;
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	<tPROCEDURE>
	t = <tID> {
		Symbol s;
		at.parList = new ArrayList<Symbol>();
		s = new SymbolProcedure(t.image,at.parList);
		try {
			st.insertSymbol(s);	
			st.insertBlock();
		}
		catch (AlreadyDefinedSymbolException e) {
			//error
		}
		
		at2.parList = at1.parList;
	}
	<tPARENTESIS_OPEN>
	(( lista_parametros_funcion_o_proc(at2) )?)
	{
		Symbol aux = st.getSymbol(t.image);
		if (aux instanceof SymbolProcedure) {
			System.err.println("Procedimiento");
			SymbolProcedure procedure = (SymbolProcedure) aux;
			procedure.parList = at2.parList;
		}
		
	}
	<tPARENTESIS_CLOSE>
	<tIS>
}

void cabecera_funcion(Attributes at) :
{

	Token t;
	Attributes at1 = new Attributes(), at2 = new Attributes();

}
{
	<tFUNCTION> 
	t = <tID> {
		Symbol s;
		at.parList = new ArrayList<Symbol>();
		s = new SymbolFunction(t.image, at.parList, at1.type);
		try {
			st.insertSymbol(s);
			st.insertBlock();
		}
		catch (AlreadyDefinedSymbolException e) {
			// error
		}
		at2.parList = at.parList;
	}
	<tPARENTESIS_OPEN>
	( lista_parametros_funcion_o_proc(at2) )?
	<tPARENTESIS_CLOSE>
	<tRETURN> tipo_variable(at1) <tIS>
	{
	
		Symbol aux = st.getSymbol(t.image);
		if (aux instanceof SymbolFunction) {
			System.err.println("Funcion");
			SymbolFunction funcion = (SymbolFunction) aux;
			funcion.returnType = at1.type;
			funcion.parList = at2.parList;
		}
		
	}
}

void inst_leer():
{

}
{
	<tGET> <tPARENTESIS_OPEN> lista_ids() <tPARENTESIS_CLOSE>
}

void inst_saltar_linea():
{

}
{
	<tSKIP_LN>
}

void inst_escribir():
{

}
{
	<tPUT> <tPARENTESIS_OPEN>
	lista_una_o_mas_exps()
	<tPARENTESIS_CLOSE>
}

void inst_escribir_linea(): 
{

}
{
	<tPUT_LN> 
	(<tPARENTESIS_OPEN> 
	lista_una_o_mas_exps()
	<tPARENTESIS_CLOSE>) ?
}

void inst_invocacion_o_asignacion(Attributes at): 
{
	Token t;
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	expresion(at1) (<tASIGN> expresion(at2)) ? // Completar parte de práctica 3

}

void inst_if():
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	<tIF> expresion(at1) <tTHEN> instrucciones()
	(<tELIF>  expresion(at2) <tTHEN> instrucciones())*
	(<tELSE> instrucciones())?
	<tEND> <tIF>
	
}

void inst_while():
{
	Attributes at = new Attributes();
}
{
	<tWHILE> expresion(at) <tLOOP> 
	instrucciones() 
	<tEND> <tLOOP>
}

void inst_return():
{
	Attributes at = new Attributes();
}
{
	<tRETURN> expresion(at)
}

void inst_null():
{

}
{
	<tNULL>
}

void instruccion() :
{
	Attributes at = new Attributes();
}
{
	( inst_leer() )
|   ( inst_saltar_linea() )
|	( inst_escribir() )
|   ( inst_escribir_linea() )
|   ( inst_invocacion_o_asignacion(at) )
|   ( inst_if() )
|   ( inst_while() )
|   ( inst_return() )
|   ( inst_null() )
}
	
void instrucciones() :
{

}
{
	(instruccion() <tPUNTOCOMA>)+
}

void expresion(Attributes at) :
{
	
}
{	
	relacion(at)
	( ((<tAND> | <tOR>) relacion(at))+ )?
}
	
void lista_una_o_mas_exps():
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	expresion(at1) (<tCOMA> expresion(at2))*
	
}

void relacion(Attributes at) :
{
	Token t;
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
}
{
	expresion_simple(at1) 
	{
		at.type = at1.type;
		at.parClass = at1.parClass;
		at.parList = at1.parList;
	}
	( 
	operador_relacional(at2) 
	expresion_simple(at3) 
	{
		if (at1.type == at3.type) {
			at.type = Symbol.Types.BOOL;
		}
		else {
			at.type = Symbol.Types.UNDEFINED;
			//error, no devolverá booleano si no se puede comparar
		}
		//completar los atributos de at
	} 
	)?
}
	
	

void operador_relacional(Attributes at) :
{
	
}
{
	<tEQU> | <tLT> | <tGT> | <tLE> | <tGE> | <tDIF>
}
	

void expresion_simple(Attributes at) :
{

}
{
	( <tSUM> |	<tRES> )? 
	termino(at)
	( ( <tSUM> | <tRES> ) termino(at) )*
}
	

void termino(Attributes at) :
{

}
{
	factor(at) ( operador_multiplicativo() factor(at) )*
}
	

void operador_multiplicativo() :
{
	
}
{
	<tMUL> | <tMOD> | <tDIV>
}
	
void factor(Attributes at) :
{

}
{
	primario(at) 
|	<tNOT> primario(at) 

}
	

void primario(Attributes at) :
{
	Token t; // revisar
}
{
	<tPARENTESIS_OPEN> expresion(at) <tPARENTESIS_CLOSE>
|	<tINT2CHAR> <tPARENTESIS_OPEN> expresion(at) <tPARENTESIS_CLOSE>
|	<tCHAR2INT> <tPARENTESIS_OPEN> expresion(at) <tPARENTESIS_CLOSE>
|	LOOKAHEAD(2) t = <tID> <tPARENTESIS_OPEN> lista_una_o_mas_exps() <tPARENTESIS_CLOSE> { //invoc. func. o comp. array
		Symbol s = null;
		try {
			s = st.getSymbol(t.image);
			if (!(s instanceof SymbolFunction)) {
				//errSem.deteccion("Se esperaba función ...");
			}
		}
		catch (SymbolNotFoundException e) {
			//errSem.deteccion(e, t);
		}
		at.isVar = false;
		at.type = ((SymbolFunction)s).returnType;
		// Procesar la lista de parametros reales ...
		//...
	}
|	t = <tID> {             //var. o func. sin pars
		Symbol s = null;
		try {
			s = st.getSymbol(t.image);
		}
		catch (SymbolNotFoundException e) {
			//errSem.deteccion(e, t);
		}
		at.isVar = true;
		at.type = s.type;
	}
|	<tCONST_INT>
|	<tCONST_CHAR>
|	<tCONST_STRING> //rn sf.primario_8(t);
|	<tTRUE>
|	<tFALSE>
}

