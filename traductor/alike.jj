//*****************************************************************
// File:   cl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   julio 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
	IGNORE_CASE = true;
	COMMON_TOKEN_ACTION = false;
	DEBUG_PARSER = false;
}

// -----------------------------------------------------------------------------


PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.attributes.*;
import java.util.ArrayList;
import lib.errores.ErrorSemantico;

//...

public class alike {
   //...

   static SymbolTable st;

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"boolean","char","character", "integer", "null", "array", 
			"mod", "not", "and", "or",
			"if", "elsif", "else", "then", "while", "loop", "true", "false",
			"procedure", "function", "is", "ref", "of", "begin", "end", "return",
			"skip_line", "put", "put_line", "get", "char2int", "int2char"
		};

		//st.insertReservedWords(palsRes);
	}

	private static void iterarYanadirEnTablaDeSimbolos(ArrayList<Token> ids, Attributes at){
		Symbol s = null;
		for (Token t : ids) {
			if (at.isArray) {
				s = new SymbolArray(t.image, at.intList.get(0), at.intList.get(1), at.type, at.parClass);
				at.parList.add(s);
			}
			else {
				if (at.type == Symbol.Types.BOOL) {
					s = new SymbolBool(t.image, at.parClass);
					at.parList.add(s);
				}
				else if (at.type == Symbol.Types.INT) {
					s = new SymbolInt(t.image, at.parClass);
					at.parList.add(s);
				}
				else if (at.type == Symbol.Types.CHAR) {
					s = new SymbolChar(t.image, at.parClass);
					at.parList.add(s);
				}
			}
			try {
				st.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e) {
				System.err.println("Already Defined: " + e.getMessage());
			}
		}
	}
   
   public static void main(String[] args) {
	   alike parser = null;
	   
		st = new SymbolTable();
    	initSymbolTable();

	   try {
		   if(args.length == 0) {
			   parser = new alike(System.in);
		   }
		   else {
			   parser = new alike(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();
		   //...
		   System.out.println("***** Análisis terminado con éxito *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.err.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.err.println("LEX_ERROR: " + e.getMessage());

	   }
	   catch (ParseException e) {
			System.err.println("Parse_exception: " + e.getMessage());
	   }
	   //...
   }
}
PARSER_END(alike)

// ----------------------------------------------------------------------------

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #UNDERSCORE: "_" >
}

SKIP : { 
	< tSPACE: " " >
| 	< tNL: "\n" >
|	< tTAB: "\t" >
|	< tENTER: "\r" >
| 	< tCOMENTARIO: "--"(~["\n"])* >
}

TOKEN : { // Tipos
	< tBOOL: "boolean" >
|	< tCHAR: "char" >
|	< tCHARACTER: "character" >
|   < tINTEGER: "integer" >
|	< tSTRING: "string" >
|	< tNULL: "null" >
|	< tARRAY: "array" >
|	< tCONST_INT: (["0"-"9"])+ >
|	< tCONST_CHAR: "\'"(~["\n","\t","\r","\f","\b","\'","\""] | ("\"\"") | ("\'\'"))"\'" >
| 	< tCONST_STRING: "\""(~["\n","\t","\r","\f","\b","\'","\""] | ("\"\"") | ("\'\'"))*"\"" >
}

TOKEN : { // Operadores
	< tASIGN: ":=" >
|	< tSUM: "+" >
|   < tRES: "-" >
|	< tEQU: "=" >
|	< tGT: ">" >
|	< tLT: "<" >
|	< tGE: ">=" >
|	< tLE: "<=" >
|	< tDIF: "/=" >
|	< tMUL: "*" >
|	< tMOD: "mod" >
|	< tDIV: "/" >
|	< tNOT: "not" >
|	< tAND: "and" >
|	< tOR: "or" >
}

TOKEN : { // Sintaxis reservada estructuras simples
	< tIF: "if" >
|	< tELIF: "elsif" >
|	< tELSE: "else" >
|	< tTHEN: "then" >
|	< tWHILE: "while" >
|	< tLOOP: "loop" >
|	< tTRUE: "true" >
|	< tFALSE: "false" >
}

TOKEN : { // Sintaxis reservada funciones
	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tREF: "ref" >
|	< tOF: "of" >
|	< tBEGIN: "begin" >
|	< tEND: "end" >
|	< tRETURN: "return" >
}

TOKEN : { // Instrucciones E/S
	< tSKIP_LN: "skip_line" >
|	< tPUT: "put" >
|	< tPUT_LN: "put_line" >
|	< tGET: "get" >
|	< tCHAR2INT: "char2int" >
|	< tINT2CHAR: "int2char" >
}

TOKEN : { // Separadores
	< tPUNTO: "." >
|	< tCOMA:	"," >
|	< tDOSPUNTOS: ".." >
|	< tDOBLEPUNTO: ":" >
|	< tPUNTOCOMA: ";" >
|	< tCORCHETES_OPEN: "[" >
|	< tCORCHETES_CLOSE: "]" >
|	< tPARENTESIS_OPEN: "(" >
|	< tPARENTESIS_CLOSE: ")" >
|	< tID: ["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","0"-"9","_"])* >
}

TOKEN_MGR_DECLS : {
	static void CommonTokenAction(Token t) {

		 String[] nombresTokens = {
			"letra", "digito", "barra baja", "espacio", "fin de linea", "tabulador", "retorno", "comentario",
			"boolean", "char", "character", "integer", "null", "array", "const integer", "const char", "const string",
			"asignacion", "suma", "resta", "comparacion igualdad", "comparacion mayor estricto", "comparacion menor estricto", 
			"comparacion mayor o igual", "comparacion menor o igual", "comparacion diferencia", "multiplicacion", "modulo", "division", "negacion logica", 
			"operador logico", "operador logico", "token", "token", "token", "token", "token", "token", "constante aritmetica", "constante aritmetica", 
			"token", "token", "token", "token", "token", "token", "token", "token", "funcion reservada", "funcion reservada", "funcion reservada", 
			"funcion reservada", "funcion reservada", "funcion reservada", "token separador", "token separador", "token separador", "token separador",
			"token separador", "token separador", "token separador", "token separador", "token separador", "identificador"
		};

		int linea = t.beginLine;
		int columna = t.beginColumn;
		String image = t.image;
		if (t.kind != 0){ // Si es distinto de fin de linea
			System.out.println("(" + linea + "," + columna + "): " + nombresTokens[t.kind-1] + " \"" + image + "\"");
		}
	}
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
/*void Programa() : 
{
	//Token t;
}
{
   ( 
	   < tBEGIN >
	   | 
	   < tBOOL > | < tCHAR > | < tCHARACTER > | < tINTEGER > | < tNULL > | < tARRAY > | < tCONST_INT > | < tCONST_CHAR > | < tCONST_STRING > 
	   |
	   < tASIGN > | < tSUM > | < tRES > | < tEQU > | < tGT > | < tLT > | < tGE > | < tLE > | < tMUL > | < tMOD > | < tDIV > | < tNOT > | < tDIF > | < tAND > | < tOR >
	   |
	   < tIF > | < tELIF > |	< tTHEN > |	< tWHILE > | < tLOOP > | < tTRUE > | < tFALSE > | <tELSE>
	   |
	   < tPROCEDURE > | < tIS > | < tREF > | < tEND > | < tRETURN > | < tOF > | <tFUNCTION>
	   |
	   < tSKIP_LN > | < tPUT > | < tPUT_LN > | < tGET > | <tCHAR2INT> | <tINT2CHAR> 
	   |
	   < tPUNTO > |	< tCOMA > |	< tDOSPUNTOS > | < tDOBLEPUNTO > | < tPUNTOCOMA > |	< tCORCHETES_OPEN > | < tCORCHETES_CLOSE > | < tPARENTESIS_OPEN > |	< tPARENTESIS_CLOSE > | < tID >
   )+
   < EOF >
}*/

 
void Programa() : 
{
	Token t;
	Attributes at = new Attributes();
	
}
{
	<tPROCEDURE>
	t = <tID> {
		Symbol s;
		at.parList = new ArrayList<Symbol>();
		s = new SymbolProcedure(t.image,at.parList,true);
		try {
			st.insertSymbol(s);	
		}
		catch (AlreadyDefinedSymbolException e) {
			ErrorSemantico.deteccion(e, t.image);
		}
	}
	<tIS>
	( declaracion_variables() )?
	( declaracion_procs_funcs() )?
	<tBEGIN>
	instrucciones()
	<tEND>
	<tPUNTOCOMA>
	{
		System.err.println(st.toString());
		st.removeBlock();
	}
	<EOF>
}
	
void declaracion_procs_funcs() :
{

}
{
	( declaracion_proc_func() )+
}

void declaracion_proc_func() :
{

}
{
	( declaracion_proc() | declaracion_func() )
}

void declaracion_func():
{
	Attributes at = new Attributes();
}
{
	cabecera_funcion(at)
	( declaracion_variables() )?
	<tBEGIN>
	instrucciones_return()
	<tEND>
	<tPUNTOCOMA>
	{
		System.err.println(st.toString());
		st.removeBlock();
	}
}

void declaracion_proc():
{
	Attributes at = new Attributes();
}
{
	cabecera_procedimiento(at)
	( declaracion_variables() )?
	<tBEGIN>
	instrucciones() 
	<tEND>
	<tPUNTOCOMA>
	{
		System.err.println(st.toString());
		st.removeBlock();
	}
}

ArrayList<Token> lista_ids():
{
	ArrayList<Token> ids = new ArrayList<Token>();
	Token t;
}
{

	t = <tID> {ids.add(t);} (<tCOMA> t = <tID> {ids.add(t);})*  //Aceptamos que una lista de ids pueda estar formada por un solo id
	{return ids;}
}

void declaracion_variables() :
{

}
{
	( declaracion_var() )+
}

void declaracion_variables_puntocoma() :
{
	Attributes at = new Attributes();
}
{
	( declaracion_var_puntocoma(at) )+
}
		
void tipo_variable(Attributes at) :
{

}
{
	<tBOOL> { at.type = Symbol.Types.BOOL; }
| 	<tCHAR> { at.type = Symbol.Types.CHAR; }
| 	<tCHARACTER> { at.type = Symbol.Types.CHAR; }
| 	<tINTEGER> { at.type = Symbol.Types.INT; }
	
}

void rango(Attributes at) :
{
	Token t1, t2;
}
{
	t1 = <tCONST_INT> <tDOSPUNTOS> t2 = <tCONST_INT> 
	{
		Integer inicio,fin;
		inicio = Integer.valueOf(t1.image);
		fin = Integer.valueOf(t2.image);
		if(inicio > fin) {
			ErrorSemantico.deteccion("Rango invalido");
		}
		else {
			at.intList.add(inicio);
			at.intList.add(fin);
		}
	}
}

void estructura_array(Attributes at):
{
}
{
	<tARRAY> <tPARENTESIS_OPEN> rango(at) <tPARENTESIS_CLOSE> <tOF> tipo_variable(at)
	{
		at.isArray = true;
		// Faltarían más cosas de atribuir a at?
	}
}

void declaracion_var_puntocoma(Attributes at):
{
	ArrayList<Token> ids;
	Attributes at1 = new Attributes(), at2 = new Attributes();
	Symbol s;
}
{
	ids = lista_ids() <tDOBLEPUNTO> {
		at1.parClass = Symbol.ParameterClass.VAL; 
		at2.parClass = Symbol.ParameterClass.VAL;
		}
	(<tREF> {
		at1.parClass = Symbol.ParameterClass.REF; 
		at2.parClass = Symbol.ParameterClass.REF;
		})?
	( tipo_variable(at1) 
		{ iterarYanadirEnTablaDeSimbolos(ids,at1);
		  at.parList = at1.parList;
		} 
	  | 	
  	  estructura_array(at2) // Aquí se supone que permitimos vectores ya sea por valor o ref como parametros
		{ iterarYanadirEnTablaDeSimbolos(ids,at2); 
		  at.parList = at2.parList;
		}
	)
}

void declaracion_var():
{
	ArrayList<Token> ids;
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	ids = lista_ids() 
	<tDOBLEPUNTO>
	( tipo_variable(at1) { iterarYanadirEnTablaDeSimbolos(ids,at1);	} | 	
	  estructura_array(at2) { iterarYanadirEnTablaDeSimbolos(ids,at2); })
	<tPUNTOCOMA>
}

void lista_parametros_funcion_o_proc(Attributes at):
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	declaracion_var_puntocoma(at1) 
	{
		for (Symbol s : at1.parList) {
			at.parList.add(s);
		}
	} 
	(
		<tPUNTOCOMA> declaracion_var_puntocoma(at2)
		{
			for (Symbol s : at2.parList) {
				at.parList.add(s);
			}
		}
	)*	
}

void cabecera_procedimiento(Attributes at) :
{
	Token t;
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	<tPROCEDURE>
	t = <tID> {
		Symbol s;
		at.parList = new ArrayList<Symbol>();
		s = new SymbolProcedure(t.image,at.parList);
		try {
			st.insertSymbol(s);	
			st.insertBlock();
		}
		catch (AlreadyDefinedSymbolException e) {
			ErrorSemantico.deteccion(e,t.image);
		}
		
		at2.parList = at1.parList;
	}
	<tPARENTESIS_OPEN>
	(( lista_parametros_funcion_o_proc(at2) )?)
	{
		try {
			Symbol aux = st.getSymbol(t.image);
			if (aux instanceof SymbolProcedure) {
				//System.err.println("Procedimiento");
				SymbolProcedure procedure = (SymbolProcedure) aux;
				procedure.parList = at2.parList;
			}
		}
		catch (SymbolNotFoundException e) {
			ErrorSemantico.deteccion(e,t.image);
		}
		
		
	}
	<tPARENTESIS_CLOSE>
	<tIS>
}



void cabecera_funcion(Attributes at) :
{

	Token t;
	Attributes at1 = new Attributes(), at2 = new Attributes();

}
{
	<tFUNCTION> 
	t = <tID> {
		Symbol s;
		at.parList = new ArrayList<Symbol>();
		s = new SymbolFunction(t.image, at.parList, at1.type);
		try {
			st.insertSymbol(s);
			st.insertBlock();
		}
		catch (AlreadyDefinedSymbolException e) {
			ErrorSemantico.deteccion(e,t.image);
		}
		at2.parList = at.parList;
	}
	<tPARENTESIS_OPEN>
	( lista_parametros_funcion_o_proc(at2) )?
	<tPARENTESIS_CLOSE>
	<tRETURN> tipo_variable(at1) <tIS>
	{
		try {
			Symbol aux = st.getSymbol(t.image);
			if (aux instanceof SymbolFunction) {
				//System.err.println("Funcion");
				SymbolFunction funcion = (SymbolFunction) aux;
				funcion.returnType = at1.type;
				funcion.parList = at2.parList;
			}
		}
		catch (SymbolNotFoundException e) {
			ErrorSemantico.deteccion(e, t.image);
		}
	}
}



void inst_leer():
{
	ArrayList<Token> ids;
}
{
	<tGET> <tPARENTESIS_OPEN> 
	
	ids = lista_ids() {
		for(Token t : ids) {
			try {
				Symbol s = st.getSymbol(t.image);
				if (!((s.type == Symbol.Types.CHAR) || (s.type == Symbol.Types.INT))) {
					ErrorSemantico.deteccion("Se esperaba caracter o entero <inst_leer>");
				}
			}
			catch(SymbolNotFoundException e){
				ErrorSemantico.deteccion(e, t.image);
			}	
		}
	}
	<tPARENTESIS_CLOSE>
}



void inst_saltar_linea():
{

}
{
	<tSKIP_LN>
}



void inst_escribir():
{
	ArrayList<Attributes> ats = new ArrayList<Attributes>();
}
{
	<tPUT> <tPARENTESIS_OPEN>
	lista_una_o_mas_exps(ats)
	{
		for (Attributes at : ats) {
			if (!((at.type == Symbol.Types.INT) || (at.type == Symbol.Types.BOOL) || 
			      (at.type == Symbol.Types.CHAR) || (at.type == Symbol.Types.STRING))) {
				ErrorSemantico.deteccion("Se esperaba entero, booleano, caracter o string <inst_escribir>");
			}
		}
	}
	<tPARENTESIS_CLOSE>
}



void inst_escribir_linea(): 
{
	ArrayList<Attributes> ats = new ArrayList<Attributes>();
}
{
	<tPUT_LN> 
	(<tPARENTESIS_OPEN> 
	lista_una_o_mas_exps(ats)
	{
		for (Attributes at : ats) {
			if (!((at.type == Symbol.Types.INT) || (at.type == Symbol.Types.BOOL) 
			|| (at.type == Symbol.Types.CHAR) || (at.type == Symbol.Types.STRING))) {
				System.err.println(at.type);
				ErrorSemantico.deteccion("Se esperaba entero, booleano, caracter o string <inst_escribir_linea>");
			}
		}
	}
	<tPARENTESIS_CLOSE>) ?
}



void inst_invocacion_o_asignacion(Attributes at): 
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{	// o componente de vector, o <tID> (cambiarlo por expresion), o procedimiento (con y sin parametros)
	expresion(at1) {
		try {
			Symbol s = st.getSymbol(at1.name);
			if ((s instanceof SymbolProcedure) && (((SymbolProcedure) s).principal)) {
				ErrorSemantico.deteccion("El procedimiento principal no es invocable");
			}
		}
		catch(SymbolNotFoundException e){
			ErrorSemantico.deteccion(e, at1.name);
		}
	}
	(<tASIGN> 
	 expresion(at2) {
		Symbol s = null, s2 = null;
		//System.out.println("----------->" + at1.name);
		//System.out.println("----------->" + at2.name);
		try {
			s = st.getSymbol(at1.name);
			s2 = st.getSymbol(at2.name);
			//System.out.println("----------->" + s.toString());
			//System.out.println("----------->" + s2.toString());

			// Funciones y procedimientos no pueden ser asignables.
			if (s instanceof SymbolFunction || s instanceof SymbolProcedure) {
				ErrorSemantico.deteccion("Funcion o procedimiento no son asignables");
			}
			else if (s2 instanceof SymbolProcedure) {
				ErrorSemantico.deteccion("No se puede asignar un procedimiento");
			}
			else if (s2 instanceof SymbolFunction){
				// Si variable es escalar y tipos at1 y at2 iguales -> OK
				// Doy por asumido que escalares agrupa tmb char, string y bool
				if(!((at1.type == Symbol.Types.INT || at1.type == Symbol.Types.CHAR ||
			    at1.type == Symbol.Types.BOOL) && at1.type == ((SymbolFunction)s2).returnType)){
					ErrorSemantico.deteccion("Asignacion con tipos distintos");
				}
				// Si es una componente de vector y tipos at1 y at2 iguales -> OK
				if(at1.isVecComp && (((SymbolArray) s).baseType != ((SymbolFunction)s2).returnType)){
					ErrorSemantico.deteccion("La componente del vector no es del tipo del vector");
				}
			}
			else {
				// Si variable es escalar y tipos at1 y at2 iguales -> OK
				// Doy por asumido que escalares agrupa tmb char, string y bool
				if(!((at1.type == Symbol.Types.INT || at1.type == Symbol.Types.CHAR ||
			    at1.type == Symbol.Types.BOOL) && at1.type == at2.type)){
					ErrorSemantico.deteccion("Asignacion con tipos distintos");
				}
				// Si es una componente de vector y tipos at1 y at2 iguales -> OK
				if(at1.isVecComp && (((SymbolArray) s).baseType != at2.type)){
					System.out.println(at1.name);
					ErrorSemantico.deteccion("La componente del vector no es del tipo del vector");
				}
			}

		}
		catch (SymbolNotFoundException e){
			ErrorSemantico.deteccion(e, at1.name);
		}
	 } 
	
	) ? 

}



void inst_if():
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	<tIF> expresion(at1) 
	{
		if (at1.type != Symbol.Types.BOOL) {
			ErrorSemantico.deteccion("Se esperaba booleano <if>");
		}
	} 
	<tTHEN> instrucciones_return()
	(<tELIF>  expresion(at2) 
	{

			if (at2.type != Symbol.Types.BOOL) {
			ErrorSemantico.deteccion("Se esperaba booleano <elif>");
		}
	} 
	<tTHEN> instrucciones_return())*
	(<tELSE> instrucciones_return())?
	<tEND> <tIF>
	
}



void inst_while():
{
	Attributes at = new Attributes();
}
{
	<tWHILE> expresion(at) <tLOOP> 
	instrucciones_return() 
	<tEND> <tLOOP>
}



void inst_return():
{
	Attributes at = new Attributes();
}
{
	<tRETURN> expresion(at) {
		if (!((at.type == Symbol.Types.INT) || (at.type == Symbol.Types.BOOL) || (at.type == Symbol.Types.CHAR))){
			String _error = "Tipo incompatible a devolver en return, (" + at.type.toString() + ") <inst_return>";
			ErrorSemantico.deteccion(_error);	
		}
	}
}



void inst_null():
{

}
{
	<tNULL>
}



void instruccion_return() :
{
	Attributes at = new Attributes();
}
{
	( inst_leer() )
|   ( inst_saltar_linea() )
|	( inst_escribir() )
|   ( inst_escribir_linea() )
|   ( inst_invocacion_o_asignacion(at) )
|   ( inst_if() )
|   ( inst_while() )
|   ( inst_return() )
|   ( inst_null() )
}
	

void instruccion() :
{
	Attributes at = new Attributes();
}
{
	( inst_leer() )
|   ( inst_saltar_linea() )
|	( inst_escribir() )
|   ( inst_escribir_linea() )
|   ( inst_invocacion_o_asignacion(at) )
|   ( inst_if() )
|   ( inst_while() )
|   ( inst_null() )
}


void instrucciones() :
{

}
{
	(instruccion() <tPUNTOCOMA>)+
}

void instrucciones_return() :
{

}
{
	(instruccion_return() <tPUNTOCOMA>)+
}


void expresion(Attributes at) :
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{	
	relacion(at1) {
		at.type = at1.type;
		at.name = at1.name;
	}
	(((<tAND> | <tOR>) 
	relacion(at2) 
	{
		if (!((at1.type == at2.type) && (at1.type == Symbol.Types.BOOL))) {
			at.type = Symbol.Types.UNDEFINED;
			ErrorSemantico.deteccion("Se esperaban booleanos");
		}
		else{
			at.type = at1.type;
		}
	}
	)+)?
}
	


void lista_una_o_mas_exps(ArrayList<Attributes> ats):
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	expresion(at1) {ats.add(at1);} 
	(<tCOMA> 
	expresion(at2) {
		ats.add(at2);
	}
	)*
	
}



/* CREO QUE ESTÁ COMPLETADA, SI FALTA ALGO SERÍA COMPLETAR VALORES DE at */
void relacion(Attributes at) :
{
	Attributes at1 = new Attributes(), at2 = new Attributes(), at3 = new Attributes();
}
{
	expresion_simple(at1) 
	{
		at.name = at1.name;
		at.type = at1.type;
		at.isConst = at1.isConst;
		at.isVar = at1.isVar;
		at.isVecComp = at1.isVecComp;
		//at.parClass = at1.parClass;
		//at.parList = at1.parList;
	}
	( 
	operador_relacional(at2) 
	expresion_simple(at3) 
	{
		if (at1.type == at3.type) {
			at.type = Symbol.Types.BOOL;
		}
		else {
			at.type = Symbol.Types.UNDEFINED;
			ErrorSemantico.deteccion("Tipos incompatibles ...");
		}
		at.isVar = false;
		at.isVecComp = false;
		at.isConst = true; // Me imagino que True y False son constantes no?
	} 
	)?
}
	
	

void operador_relacional(Attributes at) :
{
	
}
{
	<tEQU> | <tLT> | <tGT> | <tLE> | <tGE> | <tDIF>
}
	

/* COMPLETA */
// En 'termino' sólo se comprueba si es int cuando se detecta que hay operaciones con mul, div o mod
// En el caso de que 'termino' solo sea un factor, no se comprueba el tipo, por eso se comprueba en 
// esta función, porque podríamos recibir cualquier tipo de dato.
// Creo que se podría comprobar directamente en la función 'termino' que factor(at1) sea entero y así
// ya no tendríamos que comprobar nada en 'expresion_simple' pues siempre 'termino' será un int.
void expresion_simple(Attributes at) :
{
	Attributes at1 = new Attributes(), at2 = new Attributes();
}
{
	( <tSUM> |	<tRES> )? 
	termino(at1) {
		at.name = at1.name;
		at.type = at1.type;
		at.isConst = at1.isConst;
		at.isVar = at1.isVar;
		at.isVecComp = at1.isVecComp;
	
	}
	( ( <tSUM> | <tRES> ) termino(at2) {
		if (at1.type != Symbol.Types.INT) {
			// error: El primer termino no es un entero
			ErrorSemantico.deteccion("El primer termino no es un entero");
			System.err.println(at1.type);
			System.err.println(at1.name);
		}
		if ((at2.type != at1.type) || (at2.type != Symbol.Types.INT)){
			// error: Los tipos de terminos no coinciden o at2 no es entero
			ErrorSemantico.deteccion("Terminos no coinciden, segundo temrino no es un entero");
		}
	  } 
	)*
}
	

/* CREO QUE COMPLETADA */
void termino(Attributes at) :
{
	Attributes at1 = new Attributes(), at2 = new Attributes();

}
{
factor(at1) {at.name = at1.name; at.type = at1.type; /*System.out.println("Tipo: " + at.type);*/} ( 
		operador_multiplicativo() {
			// Aparece una operación de mul, div o mod, por lo tanto comprobamos
			// que at1 sea entero.
			if (at1.type != Symbol.Types.INT) {
				// error: El primer factor no es un entero
				ErrorSemantico.deteccion("El primer factor no es un entero");
			}
		}
	  	factor(at2) {
			// Comprobamos que at2 es mismo tipo que at1, que deberá ser un entero.
			if((at2.type != at1.type) || (at2.type != Symbol.Types.INT)) {
				// error: Los tipos de factores no coinciden o at2 no es entero
				ErrorSemantico.deteccion("Los tipos de factores no coinciden");
			}
	  	}
	)* 
}
	
/* COMPLETADA -- NO HAY QUE PASAR NADA NO? */
void operador_multiplicativo() :
{

}	
{
	<tMUL> | <tMOD> | <tDIV> 
}
	
void factor(Attributes at) :
{

}
{
	primario(at) 
|	<tNOT> primario(at) 
	{
		if (at.type != Symbol.Types.BOOL){
			ErrorSemantico.deteccion("Debe ser booleano <factor>");
		}
	}
}
	

void primario(Attributes at) :
{
	Token t; // revisar
	ArrayList<Attributes> ats = new ArrayList<Attributes>();
}
{
	<tPARENTESIS_OPEN> expresion(at) <tPARENTESIS_CLOSE>
	
|	<tINT2CHAR> <tPARENTESIS_OPEN> 
	expresion(at) 
	{
		if (at.type != Symbol.Types.INT) {
			ErrorSemantico.deteccion("Se esperaba entero <int2char>");
		}
		else {
			at.type = Symbol.Types.CHAR;
		}
	}
	<tPARENTESIS_CLOSE>

|	<tCHAR2INT> <tPARENTESIS_OPEN> 
	expresion(at) 
	{
		if (at.type != Symbol.Types.CHAR) {
			ErrorSemantico.deteccion("Se esperaba caracter <char2int>");
		}
		else {
			at.type = Symbol.Types.INT;
		}
	}
	<tPARENTESIS_CLOSE>
	
|	LOOKAHEAD(2) t = <tID> <tPARENTESIS_OPEN> lista_una_o_mas_exps(ats) <tPARENTESIS_CLOSE> { //invoc. func. o comp. array
		Symbol s = null;
		try {
			s = st.getSymbol(t.image);
			if (s instanceof SymbolArray) {
				at.isVecComp = true;
			}
			else if ((s instanceof SymbolProcedure)){

				if(ats.size() != ((SymbolProcedure)s).parList.size()) {
					ErrorSemantico.deteccion("Numero incorrecto de parametros");
				}
				else {
					for (int i = 0; i < ats.size(); i++) {
						Attributes atP;
						Symbol sP;
						atP = ats.get(i);
						sP = ((SymbolProcedure)s).parList.get(i);

						if (atP.type != sP.type) {
							ErrorSemantico.deteccion("Los tipos de los parametros no coinciden");
							break;
						}
					}
				}
			}
			else if ((s instanceof SymbolFunction)){
				
				if(ats.size() != ((SymbolFunction)s).parList.size()) {
					ErrorSemantico.deteccion("Numero incorrecto de parametros");
				}
				else {
					for (int i = 0; i < ats.size(); i++) {
						Attributes atF;
						Symbol sF;
						atF = ats.get(i);
						sF = ((SymbolFunction)s).parList.get(i);

						if (atF.type != sF.type) {
							ErrorSemantico.deteccion("Los tipos de los parametros no coinciden");
							break;
						}
					}
					at.type = ((SymbolFunction)s).returnType;
				}
			}
			else {
				ErrorSemantico.deteccion("Se esperaba componente de vector, función o procedimiento ...");
			}
		}
		catch (SymbolNotFoundException e) {
			ErrorSemantico.deteccion(e, t.image);
		}
		at.isVar = false;
		at.name = t.image;
		//at.type = ((SymbolFunction)s).returnType; esto daba problemas
		// Procesar la lista de parametros reales ...
		//...
	}
|	t = <tID> {             //var. o func. sin pars 
		//¿No faltaria añadirla a la tabla semántica?
		Symbol s = null;
		try {
			s = st.getSymbol(t.image);
			at.isVar = true;
			at.type = s.type;
			at.name = t.image;
		}
		catch (SymbolNotFoundException e) {
			ErrorSemantico.deteccion(e, t.image);
		}
	}
|	<tCONST_INT> {
		at.isVar = false;
		at.type = Symbol.Types.INT;
		at.isConst = true;
	}
|	<tCONST_CHAR> {
		at.isVar = false;
		at.type = Symbol.Types.CHAR;
		at.isConst = true;
	}
|	<tCONST_STRING> { //rn sf.primario_8(t); 
		at.isVar = false;
		at.type = Symbol.Types.STRING;
		at.isConst = true;
	}

|	<tTRUE> {
		at.isVar = false;
		at.type = Symbol.Types.BOOL;
		at.isConst = true;
	}
|	<tFALSE> {
		at.isVar = false;
		at.type = Symbol.Types.BOOL;
		at.isConst = true;
	}
}

